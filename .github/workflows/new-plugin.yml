name: New UE Plugin Project
'on':
  workflow_dispatch:
    inputs:
      org:
        description: GitHub org or user
        required: true
        default: lifelike-and-believable
      template_repo:
        description: Template repo (org/name)
        required: true
        default: lifelike-and-believable/ue-plugin-template
      visibility:
        description: private|public|internal
        required: true
        default: private
      repo_name:
        description: Optional explicit repo name
        required: false
      requirements_file:
        description: 'Path to requirements file in factory repo (e.g., specs/my-plugin.md) - takes precedence over requirements field'
      plugin_name:
        description: 'Optional plugin name (if blank, will be derived from requirements)'
        required: false
      ue_version:
        description: 'Optional UE version (e.g., 5.5, 5.6). Defaults to 5.6'
        required: false
      requirements:
        description: 'Freeform requirements prompt (used if requirements_file is not provided)'
        required: false
jobs:
  factory:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
      actions: write
    steps:
      - uses: actions/checkout@v4
      - name: Install deps
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          if ! command -v gh >/dev/null; then
            type -p curl >/dev/null && curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/gi[...]
            sudo apt update && sudo apt install gh -y
          fi
      - name: Authenticate gh
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: gh auth status
      - name: Load requirements
        id: load_req
        run: |
          if [ -n "${{ inputs.requirements_file }}" ]; then
            if [ ! -f "${{ inputs.requirements_file }}" ]; then
              echo "Error: Requirements file '${{ inputs.requirements_file }}' not found"
              exit 1
            fi
            REQ=$(cat "${{ inputs.requirements_file }}")
            echo "Loaded requirements from file: ${{ inputs.requirements_file }}"
          else
            REQ="${{ inputs.requirements }}"
            if [ -z "$REQ" ]; then
              echo "Warning: No requirements provided. Parser will use defaults (AutoPlugin, UE 5.6)"
            else
              echo "Using inline requirements"
            fi
          fi
          # Use heredoc to safely handle multiline content
          echo "requirements<<EOF" >> $GITHUB_OUTPUT
          echo "$REQ" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      - name: Parse requirements
        id: parse
        env:
          REQ: ${{ steps.load_req.outputs.requirements }}
          PLUGIN_NAME: ${{ inputs.plugin_name }}
          UE_VERSION: ${{ inputs.ue_version }}
        run: |
          python3 scripts/parser.py > spec.json
          PLUGIN_NAME=$(jq -r .plugin_name spec.json)
          UE_VERSION=$(jq -r .ue_version spec.json)
          echo "plugin_name=$PLUGIN_NAME" >> $GITHUB_OUTPUT
          echo "ue_version=$UE_VERSION" >> $GITHUB_OUTPUT
          echo "✓ Resolved plugin name: $PLUGIN_NAME"
          echo "✓ Resolved UE version: $UE_VERSION"
          
      - name: Create repository from template
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: |
          PLUGIN="${{ steps.parse.outputs.plugin_name }}"
          REPO_NAME="${{ inputs.repo_name }}"
          
          if [ -z "$REPO_NAME" ]; then
            SLUG=$(echo "$PLUGIN" | tr "[:upper:]" "[:lower:]")
            REPO_NAME="ue-$SLUG"
          fi
          
          echo "Creating repository ${{ inputs.org }}/$REPO_NAME from template ${{ inputs.template_repo }}"
          gh repo create "${{ inputs.org }}/$REPO_NAME" \
            --${{ inputs.visibility }} \
            --template "${{ inputs.template_repo }}"
          
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          
      - name: Add FACTORY_ADMIN_TOKEN secret to new repo
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: |
          echo "Adding FACTORY_ADMIN_TOKEN secret to new repository..."
          
          # Add the secret to the newly created repo using gh CLI
          echo "${{ secrets.FACTORY_ADMIN_TOKEN }}" | gh secret set FACTORY_ADMIN_TOKEN \
            --repo "${{ inputs.org }}/${{ env.REPO_NAME }}" \
            --body -
          
          echo "✓ Secret added successfully to ${{ inputs.org }}/${{ env.REPO_NAME }}"
      
      - name: Clone new repository
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: |
          echo "Cloning ${{ inputs.org }}/${{ env.REPO_NAME }}..."
          git clone "https://x-access-token:${{ secrets.FACTORY_ADMIN_TOKEN }}@github.com/${{ inputs.org }}/${{ env.REPO_NAME }}.git" new-repo
          cd new-repo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          echo "✓ Repository cloned successfully"
      
      - name: Rename plugin files and folders
        run: |
          cd new-repo
          PLUGIN_NAME="${{ steps.parse.outputs.plugin_name }}"
          UE_VERSION="${{ steps.parse.outputs.ue_version }}"
          
          echo "Renaming plugin from SamplePlugin to $PLUGIN_NAME for UE $UE_VERSION"
          
          # Rename plugin directories and files
          # Check if the expected template structure exists
          if [ ! -d "Plugins/SamplePlugin" ]; then
            echo "Error: Expected template structure not found (Plugins/SamplePlugin missing)"
            echo "Template may not be compatible with this factory workflow"
            exit 1
          fi
          
          # Replace all occurrences of SamplePlugin with the new plugin name in files first
          # (before renaming, so git grep can find tracked files)
          # Escape special characters in PLUGIN_NAME for use in sed replacement string
          PLUGIN_NAME_ESCAPED=$(printf '%s\n' "$PLUGIN_NAME" | sed 's/[&/\]/\\&/g')
          
          # Count files before replacement for better logging
          FILE_COUNT=$(git grep -lz "SamplePlugin" 2>/dev/null | tr '\0' '\n' | wc -l)
          
          # Use -z and xargs -0 to handle filenames with special characters safely
          if [ "$FILE_COUNT" -gt 0 ]; then
            echo "Found $FILE_COUNT file(s) containing 'SamplePlugin'"
            git grep -lz "SamplePlugin" 2>/dev/null | xargs -0 sed -i "s/SamplePlugin/$PLUGIN_NAME_ESCAPED/g"
            echo "✓ Replaced SamplePlugin references in file contents"
          else
            echo "⚠ No SamplePlugin references found in tracked files"
            echo "This may indicate an issue with the template structure or that the template has already been customized"
          fi
          
          # Rename plugin folder
          mv Plugins/SamplePlugin "Plugins/$PLUGIN_NAME"
          echo "✓ Renamed plugin folder"
          
          # Rename module source files in each directory before renaming the directories
          # This ensures files like SamplePlugin.cpp become PluginName.cpp
          for module_dir in "Plugins/$PLUGIN_NAME/Source/SamplePlugin" "Plugins/$PLUGIN_NAME/Source/SamplePluginEditor" "Plugins/$PLUGIN_NAME/Source/SamplePluginTests"; do
            if [ -d "$module_dir" ]; then
              module_basename=$(basename "$module_dir")
              # Rename .cpp, .h, and .Build.cs files that match the module name
              for ext in cpp h Build.cs; do
                if [ -f "$module_dir/$module_basename.$ext" ]; then
                  new_module_name=$(echo "$module_basename" | sed "s/SamplePlugin/$PLUGIN_NAME_ESCAPED/g")
                  mv "$module_dir/$module_basename.$ext" "$module_dir/$new_module_name.$ext"
                  echo "✓ Renamed $module_basename.$ext to $new_module_name.$ext"
                fi
              done
            fi
          done
          
          # Rename source folders (only if they exist)
          if [ -d "Plugins/$PLUGIN_NAME/Source/SamplePlugin" ]; then
            mv "Plugins/$PLUGIN_NAME/Source/SamplePlugin" "Plugins/$PLUGIN_NAME/Source/$PLUGIN_NAME"
            echo "✓ Renamed source folder: SamplePlugin -> $PLUGIN_NAME"
          fi
          
          if [ -d "Plugins/$PLUGIN_NAME/Source/SamplePluginEditor" ]; then
            mv "Plugins/$PLUGIN_NAME/Source/SamplePluginEditor" "Plugins/$PLUGIN_NAME/Source/${PLUGIN_NAME}Editor"
            echo "✓ Renamed source folder: SamplePluginEditor -> ${PLUGIN_NAME}Editor"
          fi
          
          if [ -d "Plugins/$PLUGIN_NAME/Source/SamplePluginTests" ]; then
            mv "Plugins/$PLUGIN_NAME/Source/SamplePluginTests" "Plugins/$PLUGIN_NAME/Source/${PLUGIN_NAME}Tests"
            echo "✓ Renamed source folder: SamplePluginTests -> ${PLUGIN_NAME}Tests"
          fi
          
          # Rename .uplugin file (only if it exists)
          if [ -f "Plugins/$PLUGIN_NAME/SamplePlugin.uplugin" ]; then
            mv "Plugins/$PLUGIN_NAME/SamplePlugin.uplugin" "Plugins/$PLUGIN_NAME/${PLUGIN_NAME}.uplugin"
            echo "✓ Renamed .uplugin file"
          fi
          
          # Update UE version in project file (only if it exists)
          if [ -f "ProjectSandbox/ProjectSandbox.uproject" ]; then
            # Escape UE_VERSION for use in sed replacement string
            UE_VERSION_ESCAPED=$(printf '%s\n' "$UE_VERSION" | sed 's/[&/\]/\\&/g')
            sed -i "s/\"EngineAssociation\": \"5.6\"/\"EngineAssociation\": \"$UE_VERSION_ESCAPED\"/g" ProjectSandbox/ProjectSandbox.uproject
            echo "✓ Updated UE version in project file"
          fi
          
          # Verify rename was successful
          echo ""
          echo "Verification:"
          if [ -d "Plugins/$PLUGIN_NAME" ]; then
            echo "✓ Plugin directory: Plugins/$PLUGIN_NAME"
          else
            echo "✗ ERROR: Plugin directory not found: Plugins/$PLUGIN_NAME"
            exit 1
          fi
          
          if [ -f "Plugins/$PLUGIN_NAME/${PLUGIN_NAME}.uplugin" ]; then
            echo "✓ Plugin descriptor: Plugins/$PLUGIN_NAME/${PLUGIN_NAME}.uplugin"
          else
            echo "✗ ERROR: Plugin descriptor not found: Plugins/$PLUGIN_NAME/${PLUGIN_NAME}.uplugin"
            exit 1
          fi
          
          # Check if old name still exists (it shouldn't)
          if git grep -q "SamplePlugin" 2>/dev/null; then
            echo "⚠ WARNING: 'SamplePlugin' still found in some files:"
            git grep "SamplePlugin" | head -10
          else
            echo "✓ Old plugin name removed from all tracked files"
          fi
          
          echo ""
          echo "✓ Plugin renamed successfully"
      
      - name: Commit and push rename changes
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: |
          cd new-repo
          
          # Check if there are any changes
          if [ -z "$(git status --porcelain)" ]; then
            echo "No changes to commit (rename may have been idempotent or skipped)"
            echo "RENAME_COMMIT_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV
          else
            PLUGIN_NAME="${{ steps.parse.outputs.plugin_name }}"
            UE_VERSION="${{ steps.parse.outputs.ue_version }}"
            
            git add -A
            git commit -m "Rename plugin to $PLUGIN_NAME for UE $UE_VERSION"
            git push origin main
            
            COMMIT_SHA=$(git rev-parse HEAD)
            echo "RENAME_COMMIT_SHA=$COMMIT_SHA" >> $GITHUB_ENV
            echo "✓ Changes committed and pushed to main"
            echo "✓ Commit SHA: $COMMIT_SHA"
          fi
      
      - name: Apply branch protection
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: |
          echo "Applying branch protection to main branch..."
          
          # Apply branch protection rules via GitHub API
          gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ inputs.org }}/${{ env.REPO_NAME }}/branches/main/protection" \
            -f "required_status_checks[strict]=true" \
            -f "required_status_checks[contexts][]=Build (Win64)" \
            -f "required_status_checks[contexts][]=Automation Tests (Win64)" \
            -f "enforce_admins=true" \
            -f "required_pull_request_reviews=null" \
            -f "restrictions=null" \
            -f "allow_force_pushes=false" \
            -f "allow_deletions=false" \
            -f "required_linear_history=false" || echo "Warning: Branch protection setup failed. May need to be configured manually."
          
          echo "✓ Branch protection applied"
          
      - name: Create issue and assign to Copilot Agent
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: |
          PLUGIN="${{ steps.parse.outputs.plugin_name }}"
          UE_VERSION="${{ steps.parse.outputs.ue_version }}"
          REQUIREMENTS="${{ steps.load_req.outputs.requirements }}"
          
          # Construct the problem statement for Copilot Agent using envsubst for safe variable substitution
          export PLUGIN UE_VERSION REQUIREMENTS
          
          cat > issue_body.md << 'EOF'
          # Implement Unreal Engine Plugin: ${PLUGIN}
          
          ## Requirements
          ${REQUIREMENTS}
          
          ## Technical Context
          - Plugin Name: ${PLUGIN}
          - Unreal Engine Version: ${UE_VERSION}
          - Target Platforms: Win64
          - Template Structure: This repo was created from ue-plugin-template
          - **The plugin has already been renamed** from SamplePlugin to ${PLUGIN}
          
          ## Tasks
          1. Implement the plugin functionality based on the requirements above
          
          2. Ensure all tests in `Source/${PLUGIN}Tests/` are updated and pass
          
          3. Update README.md with plugin-specific documentation
          
          4. Add any additional files, classes, or modules needed for the plugin functionality
          
          ## Build & Test
          The repo has a `pr-ci.yml` workflow that will automatically:
          - Build the plugin using UAT
          - Run automation tests
          - Upload artifacts
          
          Please ensure your implementation will build and pass tests on Windows with UE ${UE_VERSION} installed at `C:\Program Files\Epic Games\UE_${UE_VERSION}`.
          
          ## Definition of Done
          - [ ] Plugin functionality implemented according to requirements
          - [ ] All tests pass (Build and Automation Tests)
          - [ ] README.md updated with plugin documentation
          - [ ] Code follows Unreal Engine coding standards
          - [ ] PR created and ready for review
          EOF
          
          # Use envsubst for safe variable substitution
          envsubst < issue_body.md > issue_body_final.md
          mv issue_body_final.md issue_body.md
          
          # Create the issue and assign to @copilot
          echo "Creating issue in ${{ inputs.org }}/${{ env.REPO_NAME }}"
          ISSUE_URL=$(gh issue create \
            --repo "${{ inputs.org }}/${{ env.REPO_NAME }}" \
            --title "Implement $PLUGIN plugin" \
            --body-file issue_body.md \
            --assignee @copilot)
          
          echo "ISSUE_URL=$ISSUE_URL" >> $GITHUB_ENV
          echo "✓ Issue created: $ISSUE_URL"
      
      - name: Generate job summary
        run: |
          PLUGIN="${{ steps.parse.outputs.plugin_name }}"
          UE_VERSION="${{ steps.parse.outputs.ue_version }}"
          REPO_URL="https://github.com/${{ inputs.org }}/${{ env.REPO_NAME }}"
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ✓ Plugin Factory Complete
          
          **Plugin Name:** $PLUGIN  
          **UE Version:** $UE_VERSION  
          **Repository:** [${{ inputs.org }}/${{ env.REPO_NAME }}]($REPO_URL)
          
          ### Actions Taken
          - ✓ Created repository from template
          - ✓ Renamed plugin from SamplePlugin to $PLUGIN
          - ✓ Committed rename changes ([commit ${{ env.RENAME_COMMIT_SHA }}]($REPO_URL/commit/${{ env.RENAME_COMMIT_SHA }}))
          - ✓ Applied branch protection to main
          - ✓ Created implementation issue for Copilot Agent
          
          ### Next Steps
          The GitHub Copilot Coding Agent has been assigned to implement the plugin functionality. Monitor the [issue](${{ env.ISSUE_URL }}) for progress.
          
          ### Links
          - [Repository]($REPO_URL)
          - [Issue](${{ env.ISSUE_URL }})
          - [Rename Commit]($REPO_URL/commit/${{ env.RENAME_COMMIT_SHA }})
          EOF
          
          echo "✓ Job summary generated"

name: New UE Plugin Project
'on':
  workflow_dispatch:
    inputs:
      org:
        description: GitHub org or user
        required: true
        default: lifelike-and-believable
      template_repo:
        description: Template repo (org/name)
        required: true
        default: lifelike-and-believable/ue-plugin-template
      visibility:
        description: private|public|internal
        required: true
        default: private
      repo_name:
        description: Optional explicit repo name
        required: false
      requirements_file:
        description: 'Path to requirements file in factory repo (e.g., specs/my-plugin.md) - takes precedence over requirements field'
      plugin_name:
        description: 'Optional plugin name (if blank, will be derived from requirements)'
        required: false
      ue_version:
        description: 'Optional UE version (e.g., 5.5, 5.6). Defaults to 5.6'
        required: false
      requirements:
        description: 'Freeform requirements prompt (used if requirements_file is not provided)'
        required: false
jobs:
  factory:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
      actions: write
    steps:
      - uses: actions/checkout@v4
      - name: Install deps
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          if ! command -v gh >/dev/null; then
            type -p curl >/dev/null && curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list
            sudo apt update && sudo apt install gh -y
          fi
      - name: Authenticate gh
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: gh auth status
      - name: Load requirements
        id: load_req
        run: |
          if [ -n "${{ inputs.requirements_file }}" ]; then
            if [ ! -f "${{ inputs.requirements_file }}" ]; then
              echo "Error: Requirements file '${{ inputs.requirements_file }}' not found"
              exit 1
            fi
            REQ=$(cat "${{ inputs.requirements_file }}")
            echo "Loaded requirements from file: ${{ inputs.requirements_file }}"
          else
            REQ="${{ inputs.requirements }}"
            if [ -z "$REQ" ]; then
              echo "Warning: No requirements provided. Parser will use defaults (AutoPlugin, UE 5.6)"
            else
              echo "Using inline requirements"
            fi
          fi
          # Write requirements to file for downstream use
          # Using printf to safely handle special characters and prevent command execution
          printf '%s' "$REQ" > requirements.txt
          echo "✓ Requirements written to requirements.txt"
      - name: Parse requirements
        id: parse
        env:
          REQUIREMENTS_FILE: requirements.txt
          PLUGIN_NAME: ${{ inputs.plugin_name }}
          UE_VERSION: ${{ inputs.ue_version }}
        run: |
          python3 scripts/parser.py > spec.json
          PLUGIN_NAME=$(jq -r .plugin_name spec.json)
          UE_VERSION=$(jq -r .ue_version spec.json)
          echo "plugin_name=$PLUGIN_NAME" >> $GITHUB_OUTPUT
          echo "ue_version=$UE_VERSION" >> $GITHUB_OUTPUT
          echo "✓ Resolved plugin name: $PLUGIN_NAME"
          echo "✓ Resolved UE version: $UE_VERSION"
          
      - name: Create repository from template
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: |
          PLUGIN="${{ steps.parse.outputs.plugin_name }}"
          REPO_NAME="${{ inputs.repo_name }}"
          
          if [ -z "$REPO_NAME" ]; then
            SLUG=$(echo "$PLUGIN" | tr "[:upper:]" "[:lower:]")
            REPO_NAME="ue-$SLUG"
          fi
          
          echo "Creating repository ${{ inputs.org }}/$REPO_NAME from template ${{ inputs.template_repo }}"
          gh repo create "${{ inputs.org }}/$REPO_NAME" \
            --${{ inputs.visibility }} \
            --template "${{ inputs.template_repo }}"
          
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          
      - name: Add FACTORY_ADMIN_TOKEN secret to new repo
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: |
          echo "Adding FACTORY_ADMIN_TOKEN secret to new repository..."
          
          # Add the secret to the newly created repo using gh CLI
          echo "${{ secrets.FACTORY_ADMIN_TOKEN }}" | gh secret set FACTORY_ADMIN_TOKEN \
            --repo "${{ inputs.org }}/${{ env.REPO_NAME }}" \
            --body -
          
          echo "✓ Secret added successfully to ${{ inputs.org }}/${{ env.REPO_NAME }}"
      
      - name: Clone new repository
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: |
          echo "Cloning ${{ inputs.org }}/${{ env.REPO_NAME }}..."
          
          # Wait for template repository to be fully populated
          # GitHub's template creation is asynchronous, so we need to retry until the expected structure exists
          MAX_ATTEMPTS=30
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Cloning repository..."
            
            # Clean up any previous failed clone attempt
            if [ -d "new-repo" ]; then
              rm -rf new-repo
            fi
            
            # Clone the repository
            if git clone "https://x-access-token:${{ secrets.FACTORY_ADMIN_TOKEN }}@github.com/${{ inputs.org }}/${{ env.REPO_NAME }}.git" new-repo; then
              cd new-repo
              
              # Check if the expected template structure exists
              if [ -d "Plugins/SamplePlugin" ]; then
                echo "✓ Repository cloned successfully with expected template structure"
                git config user.name "github-actions[bot]"
                git config user.email "github-actions[bot]@users.noreply.github.com"
                cd ..
                break
              else
                echo "Repository cloned but template structure not yet available. Waiting..."
                cd ..
                rm -rf new-repo
              fi
            else
              echo "Failed to clone repository. Waiting..."
            fi
            
            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "Error: Failed to clone repository with expected structure after $MAX_ATTEMPTS attempts"
              echo "This may indicate an issue with the template repository or GitHub's template copying process"
              exit 1
            fi
            
            echo "Waiting 10 seconds before retry..."
            sleep 10
            ATTEMPT=$((ATTEMPT + 1))
          done
      
      - name: Rename plugin files and folders
        run: |
          cd new-repo
          PLUGIN_NAME="${{ steps.parse.outputs.plugin_name }}"
          UE_VERSION="${{ steps.parse.outputs.ue_version }}"
          
          echo "Renaming plugin from SamplePlugin to $PLUGIN_NAME for UE $UE_VERSION"
          
          # Diagnostic: Show current directory structure
          echo "Current repository structure:"
          find . -type d -name "Plugins*" -o -name "SamplePlugin*" | head -20 || echo "No matching directories found"
          
          # Rename plugin directories and files
          # Check if the expected template structure exists
          if [ ! -d "Plugins/SamplePlugin" ]; then
            echo "Error: Expected template structure not found (Plugins/SamplePlugin missing)"
            echo "Template may not be compatible with this factory workflow"
            echo "Available directories in repository root:"
            ls -la
            if [ -d "Plugins" ]; then
              echo "Contents of Plugins directory:"
              ls -la Plugins/
            fi
            exit 1
          fi
          
          # Replace all occurrences of SamplePlugin with the new plugin name in files first
          # (before renaming, so git grep can find tracked files)
          # Use -z and xargs -0 to handle filenames with special characters safely
          if git grep -lz "SamplePlugin" 2>/dev/null | xargs -0 -r sed -i "s/SamplePlugin/$PLUGIN_NAME/g"; then
            echo "✓ Replaced SamplePlugin references in file contents"
          else
            echo "⚠ No SamplePlugin references found in tracked files (may be expected)"
          fi
          
          # Rename plugin folder
          mv Plugins/SamplePlugin "Plugins/$PLUGIN_NAME"
          echo "✓ Renamed plugin folder"
          
          # Rename module source files in each directory before renaming the directories
          # This ensures files like SamplePlugin.cpp and SamplePluginSmokeTest.cpp become PluginName.cpp and PluginNameSmokeTest.cpp
          for module_dir in "Plugins/$PLUGIN_NAME/Source/SamplePlugin" "Plugins/$PLUGIN_NAME/Source/SamplePluginEditor" "Plugins/$PLUGIN_NAME/Source/SamplePluginTests"; do
            if [ -d "$module_dir" ]; then
              # Rename all .cpp, .h, and .Build.cs files that contain SamplePlugin in their name
              for ext in cpp h Build.cs; do
                for file in "$module_dir"/*SamplePlugin*."$ext"; do
                  if [ -f "$file" ]; then
                    filename=$(basename "$file")
                    new_filename=$(echo "$filename" | sed "s/SamplePlugin/$PLUGIN_NAME/g")
                    mv "$file" "$module_dir/$new_filename"
                    echo "✓ Renamed $filename to $new_filename"
                  fi
                done
              done
            fi
          done
          
          # Rename source folders (only if they exist)
          if [ -d "Plugins/$PLUGIN_NAME/Source/SamplePlugin" ]; then
            mv "Plugins/$PLUGIN_NAME/Source/SamplePlugin" "Plugins/$PLUGIN_NAME/Source/$PLUGIN_NAME"
            echo "✓ Renamed source folder: SamplePlugin -> $PLUGIN_NAME"
          fi
          
          if [ -d "Plugins/$PLUGIN_NAME/Source/SamplePluginEditor" ]; then
            mv "Plugins/$PLUGIN_NAME/Source/SamplePluginEditor" "Plugins/$PLUGIN_NAME/Source/${PLUGIN_NAME}Editor"
            echo "✓ Renamed source folder: SamplePluginEditor -> ${PLUGIN_NAME}Editor"
          fi
          
          if [ -d "Plugins/$PLUGIN_NAME/Source/SamplePluginTests" ]; then
            mv "Plugins/$PLUGIN_NAME/Source/SamplePluginTests" "Plugins/$PLUGIN_NAME/Source/${PLUGIN_NAME}Tests"
            echo "✓ Renamed source folder: SamplePluginTests -> ${PLUGIN_NAME}Tests"
          fi
          
          # Rename .uplugin file (only if it exists)
          if [ -f "Plugins/$PLUGIN_NAME/SamplePlugin.uplugin" ]; then
            mv "Plugins/$PLUGIN_NAME/SamplePlugin.uplugin" "Plugins/$PLUGIN_NAME/${PLUGIN_NAME}.uplugin"
            echo "✓ Renamed .uplugin file"
          fi
          
          # Update UE version in project file (only if it exists)
          if [ -f "ProjectSandbox/ProjectSandbox.uproject" ]; then
            sed -i "s/\"EngineAssociation\": \"5.6\"/\"EngineAssociation\": \"$UE_VERSION\"/g" ProjectSandbox/ProjectSandbox.uproject
            echo "✓ Updated UE version in project file"
          fi
          
          echo "✓ Plugin renamed successfully"
      
      - name: Commit and push rename changes
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: |
          cd new-repo
          
          # Check if there are any changes
          if [ -z "$(git status --porcelain)" ]; then
            echo "No changes to commit (rename may have been idempotent or skipped)"
            echo "RENAME_COMMIT_SHA=$(git rev-parse HEAD)" >> $GITHUB_ENV
          else
            PLUGIN_NAME="${{ steps.parse.outputs.plugin_name }}"
            UE_VERSION="${{ steps.parse.outputs.ue_version }}"
            
            git add -A
            git commit -m "Rename plugin to $PLUGIN_NAME for UE $UE_VERSION"
            git push origin main
            
            COMMIT_SHA=$(git rev-parse HEAD)
            echo "RENAME_COMMIT_SHA=$COMMIT_SHA" >> $GITHUB_ENV
            echo "✓ Changes committed and pushed to main"
            echo "✓ Commit SHA: $COMMIT_SHA"
          fi
      
      - name: Apply branch protection
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: |
          echo "Applying branch protection to main branch..."
          
          # Apply branch protection rules via GitHub API
          gh api \
            --method PUT \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ inputs.org }}/${{ env.REPO_NAME }}/branches/main/protection" \
            -f "required_status_checks[strict]=true" \
            -f "required_status_checks[contexts][]=Build (Win64)" \
            -f "required_status_checks[contexts][]=Automation Tests (Win64)" \
            -f "enforce_admins=true" \
            -f "required_pull_request_reviews=null" \
            -f "restrictions=null" \
            -f "allow_force_pushes=false" \
            -f "allow_deletions=false" \
            -f "required_linear_history=false" || echo "Warning: Branch protection setup failed. May need to be configured manually."
          
          echo "✓ Branch protection applied"
          
      - name: Create issue and assign to Copilot Agent
        env:
          GH_TOKEN: ${{ secrets.FACTORY_ADMIN_TOKEN }}
        run: |
          PLUGIN="${{ steps.parse.outputs.plugin_name }}"
          UE_VERSION="${{ steps.parse.outputs.ue_version }}"
          REQUIREMENTS=$(cat requirements.txt)
          
          export PLUGIN UE_VERSION REQUIREMENTS
          
          cat > issue_body.md << 'EOF'
          # Implement Unreal Engine Plugin: ${PLUGIN}
          
          ## Requirements
          ${REQUIREMENTS}
          
          ## Technical Context
          - Plugin Name: ${PLUGIN}
          - Unreal Engine Version: ${UE_VERSION}
          - Target Platforms: Win64
          - Template Structure: This repo was created from ue-plugin-template
          - **The plugin has already been renamed** from SamplePlugin to ${PLUGIN}
          
          ## Workflow Guidance for Copilot Agent
          - Please create a feature branch and open a draft PR to main early. Iterate by pushing commits to that PR.
          - On every push, the workflow "Agent CI (Inner Loop)" runs on a self-hosted Windows runner with UE ${UE_VERSION}.
            - Job names (check contexts): "Build (Win64)" and "Automation Tests (Win64)".
          - Wait for PR checks to complete:
            - Use GitHub MCP: pull_request_read with method get_status for the PR’s head commit.
          - If checks fail:
            - Retrieve logs using GitHub MCP:
              1) list_workflow_runs for this repository/workflow
              2) list_workflow_jobs for the failing run
              3) get_job_logs with failed_only=true (or a specific job_id)
            - Use the logs to diagnose, then push a fix and repeat.
          
          ## Tasks
          1. Implement the plugin functionality based on the requirements above
          2. Ensure all tests in `Source/${PLUGIN}Tests/` are updated and pass
          3. Update README.md with plugin-specific documentation
          4. Add any additional files, classes, or modules needed for the plugin functionality
          
          ## Build & Test
          The repo has CI workflows that:
          - Build the plugin using UAT on a self-hosted Windows runner
          - Run automation tests
          - Upload artifacts
          
          Please ensure your implementation will build and pass tests on Windows with UE ${UE_VERSION} installed at `C:\Program Files\Epic Games\UE_${UE_VERSION}`.
          
          ## Definition of Done
          - [ ] Plugin functionality implemented according to requirements
          - [ ] All tests pass (Build and Automation Tests)
          - [ ] README.md updated with plugin documentation
          - [ ] Code follows Unreal Engine coding standards
          - [ ] PR created and ready for review
          EOF
          
          envsubst < issue_body.md > issue_body_final.md
          mv issue_body_final.md issue_body.md
          
          echo "Creating issue in ${{ inputs.org }}/${{ env.REPO_NAME }}"
          ISSUE_URL=$(gh issue create \
            --repo "${{ inputs.org }}/${{ env.REPO_NAME }}" \
            --title "Implement $PLUGIN plugin" \
            --body-file issue_body.md \
            --assignee @copilot)
          
          echo "ISSUE_URL=$ISSUE_URL" >> $GITHUB_ENV
          echo "✓ Issue created: $ISSUE_URL"
      
      - name: Generate job summary
        run: |
          PLUGIN="${{ steps.parse.outputs.plugin_name }}"
          UE_VERSION="${{ steps.parse.outputs.ue_version }}"
          REPO_URL="https://github.com/${{ inputs.org }}/${{ env.REPO_NAME }}"
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ✓ Plugin Factory Complete
          
          **Plugin Name:** $PLUGIN  
          **UE Version:** $UE_VERSION  
          **Repository:** [${{ inputs.org }}/${{ env.REPO_NAME }}]($REPO_URL)
          
          ### Actions Taken
          - ✓ Created repository from template
          - ✓ Renamed plugin from SamplePlugin to $PLUGIN
          - ✓ Committed rename changes ([commit ${{ env.RENAME_COMMIT_SHA }}]($REPO_URL/commit/${{ env.RENAME_COMMIT_SHA }}))
          - ✓ Applied branch protection to main
          - ✓ Created implementation issue for Copilot Agent
          
          ### Next Steps
          The GitHub Copilot Coding Agent has been assigned to implement the plugin functionality. Monitor the [issue](${{ env.ISSUE_URL }}) for progress.
          
          ### Links
          - [Repository]($REPO_URL)
          - [Issue](${{ env.ISSUE_URL }})
          - [Rename Commit]($REPO_URL/commit/${{ env.RENAME_COMMIT_SHA }})
          EOF
          
          echo "✓ Job summary generated"
